<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithm | Hi. I'm Scott Zhu]]></title>
  <link href="http://zhuhuihuihui.github.io/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://zhuhuihuihui.github.io/"/>
  <updated>2014-08-14T10:45:31+08:00</updated>
  <id>http://zhuhuihuihui.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[reverse a C-Style String]]></title>
    <link href="http://zhuhuihuihui.github.io/blog/2014/08/14/reverse-a-c-style-string/"/>
    <updated>2014-08-14T10:25:18+08:00</updated>
    <id>http://zhuhuihuihui.github.io/blog/2014/08/14/reverse-a-c-style-string</id>
    <content type="html"><![CDATA[<h2>Description</h2>

<p>Write code to reverse a C-Style String. (C-String means that “abcd” is represented as five characters, including the null character.)</p>

<hr />

<h2>Tips:</h2>

<p>A C-Style String will always have a null character at the end of the string which you can not see, but it&rsquo;s actually there. So in the case of &ldquo;abcd&rdquo;, <code>strlen()</code> will return <strong>4</strong>, which indicates the length of the string itself, while <code>sizeof()</code> will return <strong>5</strong>, the extra one space is for the <code>\0</code> known as null character.</p>

<h2>Pseudo-code</h2>

<p>```cpp
for(from 0 to the middle position of the string)
{</p>

<pre><code>switch the current character with the corresponding character at the other side of the string;
</code></pre>

<p>}
```</p>

<h2>My C++ Solution</h2>

<p>```cpp
/**</p>

<pre><code>Time complexity: O(n/2)
Space: O(1)
</code></pre>

<p><em>/
void reverse(char </em>s)
{</p>

<pre><code>if (NULL == s) return;
size_t len = strlen(s);
for (int n = 0; n &lt; len / 2; n++)
{
    char temp = s[len - n - 1];
    s[len - n - 1] = s[n];
    s[n] = temp;
}
</code></pre>

<p>}
```</p>

<h2>My Objective-C Solution</h2>

<h2>Test the Solution</h2>

<p>```cpp
int main()
{</p>

<pre><code>char s[] = "switch the current character with the corresponding character at the other side of the string";
reverse(s);
cout&lt;&lt;s&lt;&lt;endl;
return 0;
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[If a string has all unique characters]]></title>
    <link href="http://zhuhuihuihui.github.io/blog/2014/08/13/if-a-string-has-all-unique-characters/"/>
    <updated>2014-08-13T23:31:34+08:00</updated>
    <id>http://zhuhuihuihui.github.io/blog/2014/08/13/if-a-string-has-all-unique-characters</id>
    <content type="html"><![CDATA[<h2>Description</h2>

<p>Implement an algorithm to determine if a string has all unique characters. What if you can not use additional data structures?</p>

<hr />

<h2>Tips:</h2>

<p>To address a more suitable solution, we should really confirm the scope of set, where those characters come from. Is it <strong>ASCII</strong> characters? or simply 26 letters? We probably will have different solution for these cases.</p>

<p>Suppose we have a set of <strong>ASCII</strong> characters. Then we could declare a boolean array of size 256. Each element in this array represents the appearing status of a specific character in the <strong>ASCII</strong> list. All of the elements are initially set to <code>false</code> which indicate that the character at corresponding position never appeared before, while <code>true</code> indicate that the character has appeared before.</p>

<h2>Pseudo-code</h2>

<p>```cpp
declare a boolean array of size 256
for(char n in the string)
{</p>

<pre><code>if( n’s corresponding element in boolean array == true)
//means it already appeared before
{
    return false;
}
else
{
    set it to true, and continue;
}
</code></pre>

<p>}
```</p>

<h2>My C++ Solution</h2>

<p>```cpp
bool isUnique(string s)
{</p>

<pre><code>bool characterPool[256];
memset(characterPool, false, sizeof(characterPool));
size_t len = s.length();
for (int n = 0; n &lt; len; n++)
{
    int index = (int)s[n];
    if (characterPool[index] == true) return false;
    else
        characterPool[index] = true;
}
return true;
</code></pre>

<p>}
```</p>

<h2>My Objective-C Solution</h2>

<h2>Test the Solution</h2>

<p>```cpp
int main()
{</p>

<pre><code>string s1 = "ss";
string s2 = "abcdefghijklmnopqrstuvwxyzABCD1234567890";
cout &lt;&lt; isUnique(s1) &lt;&lt; " " &lt;&lt; isUnique(s2) &lt;&lt; endl;
return 0;
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Length of Last Word]]></title>
    <link href="http://zhuhuihuihui.github.io/blog/2014/02/19/length-of-last-word/"/>
    <updated>2014-02-19T00:43:09+08:00</updated>
    <id>http://zhuhuihuihui.github.io/blog/2014/02/19/length-of-last-word</id>
    <content type="html"><![CDATA[<h2>Description</h2>

<p>Given a string s consists of upper/lower-case alphabets and empty space characters <code>' '</code>, return the length of last word in the string.</p>

<p>If the last word does not exist, return 0.</p>

<p>Note: A word is defined as a character sequence consists of non-space characters only.</p>

<p>For example,
Given s = <code>"Hello World"</code>,</p>

<p>return <code>5</code>.</p>

<hr />

<h2>Tips:</h2>

<ul>
<li>Need confirm does one character count a word, in this case <strong>YES</strong></li>
<li>Start from the end of the string, <code>count++</code> until you meet a <code>' '</code></li>
<li><code>"word "</code> and <code>"word   "</code></li>
<li><code>" "</code></li>
</ul>


<hr />

<h2>My Solution</h2>

<p>```cpp
class Solution {
public:</p>

<pre><code>int lengthOfLastWord(const char *s) 
{
    if(!s) return 0;
    int length = strlen(s);
    int count = 0;
    for(int i = length - 1; i &gt;= 0; i-- )
    {
        if(s[i] == ' ' &amp;&amp; count &gt;= 1) return count;
        if(s[i] != ' ') count++;
    }
    return count;
}
</code></pre>

<p>};
```</p>
]]></content>
  </entry>
  
</feed>
